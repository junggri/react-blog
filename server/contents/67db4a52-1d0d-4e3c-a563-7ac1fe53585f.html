<p>v오늘날 90%가 넘는 브라우저가 모던 자바스크립트를 실행할 수 있음에도 불구하고, 레거시 자바스크립트는 오늘날 웹 성능 문제에 큰 원인 중 하나로 남아 있다. ES2017 문법을 사용하여 웹 페이지 또는 패키지를 작성하고 퍼블리싱 하면 성능을 매우 향상 시킬 수 있다.</p><p>모던 자바스크립트란 무엇일까</p><p>모던 자바스크립트는 특정 ECMAScript 버전으로 작성된 코드를 말하는게 아니고, 모던 브라우저에서 지원하는 문법으로 이루어진 것을 의미한다. 크롬, 엣지, 파이어폭스, 사파리와 같은 모던 웹 브라우저는 브라우저 시장의 90% 이상을 차지하고 있으며, 이 렌더링 엔진에 의존하는 다른 브라우저가 5% 쯤 된다. 따라서 글로벌 웹 트래픽의 95%가 지난 10년간 가장 널리 사용되는 자바스크립트 언어 기능을 지원하는 브라우저에서 비롯된다.</p><blockquote class="ql-align-center">아마도 엣지 레거시와 구 IE를 제거한 수치로 보면 될 것 같다. 우리나라에서는 약 93% 정도 된다.</blockquote><blockquote class="ql-align-center"><br></blockquote><p>오늘날 90%가 넘는 브라우저가 모던 자바스크립트를 실행할 수 있음에도 불구하고, 레거시 자바스크립트는 오늘날 웹 성능 문제에 큰 원인 중 하나로 남아 있다. ES2017 문법을 사용하여 웹 페이지 또는 패키지를 작성하고 퍼블리싱 하면 성능을 매우 향상 시킬 수 있다.</p><p>모던 자바스크립트란 무엇일까</p><p>모던 자바스크립트는 특정 ECMAScript 버전으로 작성된 코드를 말하는게 아니고, 모던 브라우오늘날 90%가 넘는 브라우저가 모던 자바스크립트를 실행할 수 있음에도 불구하고, 레거시 자바스크립트는 오늘날 웹 성능 문제에 큰 원인 중 하나로 남아 있다. ES2017 문법을 사용하여 웹 페이지 또는 패키지를 작성하고 퍼블리싱 하면 성능을 매우 향상 시킬 수 있다.</p><p>모던 자바스크립트란 무엇일까</p><p>모던 자바스크립트는 특정 ECMAScript 버전으로 작성된 코드를 말하는게 아니고, 모던 브라우저에서 지원하는 문법으로 이루어진 것을 의미한다. 크롬, 엣지, 파이어폭스, 사파리와 같은 모던 웹 브라우저는 브라우저 시장의 90% 이상을 차지하고 있으며, 이 렌더링 엔진에 의존하는 다른 브라우저가 5% 쯤 된다. 따라서 글로벌 웹 트래픽의 95%가 지난 10년간 가장 널리 사용되는 자바스크립트 언어 기능을 지원하는 브라우저에서 비롯된다.</p><blockquote class="ql-align-center">아마도 엣지 레거시와 구 IE를 제거한 수치로 보면 될 것 같다. 우리나라에서는 약 93% 정도 된다.</blockquote><blockquote class="ql-align-center"><br></blockquote><p>오늘날 90%가 넘는 브라우저가 모던 자바스크립트를 실행할 수 있음에도 불구하고, 레거시 자바스크립트는 오늘날 웹 성능 문제에 큰 원인 중 하나로 남아 있다. ES2017 문법을 사용하여 웹 페이지 또는 패키지를 작성하고 퍼블리싱 하면 성능을 매우 향상 시킬 수 있다.</p><p>모던 자바스크립트란 무엇일까</p><p>모던 자바스크립트는 특정 ECMAScript 버전으로 작성된 코드를 말하는게 아니고, 모던 브라우</p><p><br></p><pre class="ql-syntax" spellcheck="false">import React, { MutableRefObject, useCallback, useEffect, useRef } from "react";
import ReactQuill from "react-quill";
import WriteTopicName from "component/TextEditor/WriteTopicName";
import "react-quill/dist/quill.snow.css";
import { formats, modules } from "../../config/textEditor.config";
import { WriteBox, WriteConditionBox } from "../../styled-comp";
import { CreateNewTopic, KindOfPosts, PostsDetail, SelectTopic, TextEditBtnBox } from "component/index";
import useCommon from "../../useHooks/useCommon";
import useTopic from "../../useHooks/useTopic";
import useTextEdit from "../../useHooks/useTextEdit";
import { ITextEditModuleProps } from "../../modules/TextEditor/textEdit.interface";
import util from "../../lib/axios";
import { ITopicModuleProps } from "../../modules/Topic/topic.interface";
import { ICommonModuleProps } from "../../modules/Common/common.interface"; /**/


const Editor = ({ history }: any) =&gt; {
   const {
      data,
      setContent,
      setContentName,
      setTopic,
      setKindOfPosts,
      setDetail,
   }: ITextEditModuleProps = useTextEdit();

   const ref: any = useRef(null) as MutableRefObject&lt;any&gt;;
   const { token }: ICommonModuleProps = useCommon();
   const { topic, makeOrDeleteAndReqNewTopics }: ITopicModuleProps = useTopic();


   useEffect(() =&gt; {
      ref.current.focus();
   }, []);


   const onNameChange = useCallback((data: string) =&gt; {
      setContentName(data);
   }, [setContentName]);

   const rteChange = useCallback((content: any, delta: any, source: any, editor: any) =&gt; {
      setContent(ref.current.state.value);
   }, [setContent]);

   const onIsChecked = useCallback((name: string) =&gt; {
      setTopic(name);
   }, [setTopic]);

   const onCheckKindOfPosts = useCallback((kindOf: string) =&gt; {
      setKindOfPosts(kindOf);
   }, [setKindOfPosts]);

   const onChangeDetail = useCallback((detail: string) =&gt; {
      setDetail(detail);
   }, [setDetail]);

   const onMakeOrDelteTopic = useCallback(() =&gt; {
      makeOrDeleteAndReqNewTopics();
   }, [makeOrDeleteAndReqNewTopics]);

   const onSubmit = async (): Promise&lt;void&gt; =&gt; {
      if (data.content === ""
         || data.contentName === ""
         || data.detail === ""
         || data.kindOfPosts === ""
         || data.topicName === "") {
         alert("정보를 입력하세요");
      } else {
         const result = await util.savePost(data, token);
         if (result) history.push("/");
      }
   };


   return (
      &lt;&gt;
         &lt;WriteBox&gt;
            &lt;WriteTopicName onNameChange={onNameChange} /&gt;
            &lt;ReactQuill theme="snow"
                        onChange={rteChange}
                        modules={modules}
                        formats={formats}
                        placeholder="입력하세요."
                        ref={ref} /&gt;
         &lt;/WriteBox&gt;
         &lt;WriteConditionBox&gt;
            &lt;SelectTopic onIsChecked={onIsChecked} topic={topic} /&gt;
            &lt;CreateNewTopic topic={topic} token={token} onMakeOrDelteTopic={onMakeOrDelteTopic} /&gt;
            &lt;KindOfPosts onCheck={onCheckKindOfPosts} /&gt;
            &lt;PostsDetail onChangeDetail={onChangeDetail} /&gt;
            &lt;TextEditBtnBox onSubmit={onSubmit} /&gt;
         &lt;/WriteConditionBox&gt;
      &lt;/&gt;
   );
};


export default Editor;
</pre><p><br></p>